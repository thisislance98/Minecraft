/**
 * SocketManager - Socket.IO Client for Multiplayer
 * 
 * Based on official Socket.IO v4 documentation patterns:
 * - https://socket.io/docs/v4/client-initialization/
 * - https://socket.io/docs/v4/rooms/
 */

import { io } from 'socket.io-client';

export class SocketManager {
    constructor(game) {
        this.game = game;
        this.socket = null;
        this.roomId = null;

        // Connection state
        this.state = 'disconnected'; // disconnected, connecting, connected, in-room

        // Event callbacks
        this.callbacks = {
            onPlayerJoin: null,
            onPlayerLeave: null,
            onPlayerUpdate: null,
            onBlockChange: null,
            onWorldSeed: null,
            onRoomJoined: null,
            onError: null
        };

        // Track remote players
        this.remotePlayers = new Map();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => this.disconnect());
    }

    /**
     * Get the socket ID (player ID)
     */
    get playerId() {
        return this.socket?.id || null;
    }

    /**
     * Disconnect from current room
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.roomId = null;
        this.remotePlayers.clear();
        this.state = 'disconnected';
        if (this.game.uiManager) {
            this.game.uiManager.showNetworkStatus(null);
        }
        console.log('[SocketManager] Manual disconnect');
    }

    /**
     * Check if connected to server
     */
    get connected() {
        return this.socket?.connected || false;
    }

    /**
     * Register event callbacks
     */
    on(event, callback) {
        if (event in this.callbacks) {
            this.callbacks[event] = callback;
        }
        return this;
    }

    /**
     * Connect to Socket.IO server with retry logic
     * @param {string} serverUrl - Server URL (http:// or https://)
     * @param {number} maxRetries - Maximum connection attempts
     * @returns {Promise<boolean>}
     */
    async connect(serverUrl = null, maxRetries = 5) {
        // Determine server URL
        if (!serverUrl) {
            // Default: same origin or localhost for development
            const isDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            serverUrl = isDev ? 'http://localhost:2567' : window.location.origin;
        }

        // Already connected?
        if (this.socket?.connected) {
            console.log('[SocketManager] Already connected');
            return true;
        }

        // Retry loop
        let lastError = null;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const result = await this._attemptConnect(serverUrl, attempt, maxRetries);
                return result;
            } catch (error) {
                lastError = error;
                console.warn(`[SocketManager] Connection attempt ${attempt}/${maxRetries} failed:`, error.message);

                if (attempt < maxRetries) {
                    // Wait before retrying (exponential backoff: 1s, 2s, 4s, 8s...)
                    const delay = Math.min(1000 * Math.pow(2, attempt - 1), 8000);
                    console.log(`[SocketManager] Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // All retries failed
        console.error('[SocketManager] All connection attempts failed');
        this.game.uiManager?.showNetworkStatus('Offline');
        throw lastError;
    }

    /**
     * Single connection attempt (internal)
     */
    _attemptConnect(serverUrl, attempt, maxRetries) {
        this.state = 'connecting';
        console.log(`[SocketManager] Connecting to: ${serverUrl} (attempt ${attempt}/${maxRetries})`);

        return new Promise((resolve, reject) => {
            // Cleanup any existing socket
            if (this.socket) {
                this.socket.removeAllListeners();
                this.socket.disconnect();
            }

            // Create socket with recommended options
            this.socket = io(serverUrl, {
                // Use WebSocket transport (faster than polling)
                transports: ['websocket'],
                // Disable auto-reconnection for manual retry control
                reconnection: false,
                // Timeout settings - shorter for faster failure detection
                timeout: 5000
            });

            // === Connection Events ===

            this.socket.on('connect', () => {
                console.log('[SocketManager] Connected! Socket ID:', this.socket.id);
                this.state = 'connected';

                // Re-enable reconnection after successful connection
                this.socket.io.opts.reconnection = true;
                this.socket.io.opts.reconnectionAttempts = 5;
                this.socket.io.opts.reconnectionDelay = 1000;

                resolve(true);
            });

            this.socket.on('connect_error', (error) => {
                this.state = 'disconnected';
                reject(error);
            });

            this.socket.on('disconnect', (reason) => {
                console.log('[SocketManager] Disconnected:', reason);
                this.state = 'disconnected';
                this.roomId = null;
                this.remotePlayers.clear();
                this.game.uiManager?.showNetworkStatus(null);
            });

            this.socket.on('reconnect', (attemptNumber) => {
                console.log('[SocketManager] Reconnected after', attemptNumber, 'attempts');
                this.state = 'connected';
                // Re-join room if we were in one
                if (this.roomId) {
                    this._joinRoom(this.roomId);
                }
            });

            // === Room Events ===

            this.socket.on('room:joined', (data) => {
                console.log('[SocketManager] Joined room:', data.roomId);
                this.roomId = data.roomId;
                this.state = 'in-room';

                // Update UI
                this.game.uiManager?.showNetworkStatus(`Room: ${data.roomId.substring(0, 6)}`);

                // Process world seed
                if (data.worldSeed !== undefined) {
                    this.callbacks.onWorldSeed?.(data.worldSeed);
                }

                // Process existing players
                if (data.players && Array.isArray(data.players)) {
                    data.players.forEach(player => {
                        if (player.id !== this.playerId) {
                            this.remotePlayers.set(player.id, player);
                            this.callbacks.onPlayerJoin?.(player.id, player);
                        }
                    });
                }

                this.callbacks.onRoomJoined?.(data);
                this._updatePlayerCount();
            });

            this.socket.on('room:error', (error) => {
                console.error('[SocketManager] Room error:', error);
                this.callbacks.onError?.(error);
            });

            // === Player Events ===

            this.socket.on('player:joined', (player) => {
                console.log('[SocketManager] Player joined:', player.id);
                if (player.id !== this.playerId) {
                    this.remotePlayers.set(player.id, player);
                    this.callbacks.onPlayerJoin?.(player.id, player);
                    this._updatePlayerCount();
                }
            });

            this.socket.on('player:left', (playerId) => {
                console.log(`[SocketManager] Event 'player:left' received for ID: ${playerId}`);

                // Helper to check map contents
                console.log(`[SocketManager] Current known players: ${Array.from(this.remotePlayers.keys()).join(', ')}`);

                const player = this.remotePlayers.get(playerId);
                if (player) {
                    this.remotePlayers.delete(playerId);
                    console.log('[SocketManager] Removed from local cache:', playerId);
                } else {
                    console.warn('[SocketManager] Player ID not found in local cache:', playerId);
                }

                try {
                    console.log('[SocketManager] Calling Game.onPlayerLeave callback...');
                    this.callbacks.onPlayerLeave?.(playerId);
                } catch (e) {
                    console.error('[SocketManager] Error in onPlayerLeave callback:', e);
                }

                // Force UI update
                this._updatePlayerCount();
            });

            this.socket.on('player:update', (data) => {
                // Skip ALL processing when remote players are disabled (debug toggle)
                if (this.game._disableRemotePlayers) return;

                if (data.id !== this.playerId) {
                    // Update local cache
                    const cached = this.remotePlayers.get(data.id);
                    if (cached) {
                        Object.assign(cached, data);
                    }

                    // Update remote player entity
                    const remotePlayer = this.game.remotePlayers?.get(data.id);
                    if (remotePlayer) {
                        remotePlayer.updateFromNetwork({
                            position: data.position,
                            rotation: data.rotation,
                            animation: data.animation,
                            heldItem: data.heldItem
                        });
                    }

                    this.callbacks.onPlayerUpdate?.(data.id, data);
                }
            });

            // === World Events ===

            this.socket.on('block:changed', (data) => {
                this.callbacks.onBlockChange?.(data.x, data.y, data.z, data.blockType);
            });

            // Connection timeout
            const timeoutId = setTimeout(() => {
                if (this.state === 'connecting') {
                    this.socket.disconnect();
                    this.state = 'disconnected';
                    reject(new Error('Connection timeout'));
                }
            }, 15000);

            // Clear timeout on success
            this.socket.once('connect', () => clearTimeout(timeoutId));
        });
    }

    /**
     * Create a new room (as host)
     * @param {Object} options - Room options
     * @returns {Promise<string>} Room ID
     */
    async createRoom(options = {}) {
        if (!this.connected) {
            await this.connect();
        }

        return new Promise((resolve, reject) => {
            const roomData = {
                worldSeed: options.worldSeed || this.game.worldSeed || Math.floor(Math.random() * 1000000),
                playerName: options.playerName || 'Host',
                roomId: options.roomId
            };

            console.log('[SocketManager] Creating room...');

            // Use acknowledgment for reliable confirmation
            this.socket.emit('room:create', roomData, (response) => {
                if (response.error) {
                    reject(new Error(response.error));
                } else {
                    console.log('[SocketManager] Room created:', response.roomId);
                    this.roomId = response.roomId; // Immediate update to prevent race condition
                    resolve(response.roomId);
                }
            });

            // Timeout if no acknowledgment
            setTimeout(() => {
                if (!this.roomId) {
                    reject(new Error('Room creation timeout'));
                }
            }, 10000);
        });
    }

    /**
     * Join an existing room
     * @param {string} roomId - Room ID to join
     * @param {Object} options - Join options
     * @returns {Promise<Object>} Room data
     */
    async joinRoom(roomId, options = {}) {
        if (!this.connected) {
            await this.connect();
        }

        return this._joinRoom(roomId, options);
    }

    /**
     * Internal join room logic
     */
    _joinRoom(roomId, options = {}) {
        return new Promise((resolve, reject) => {
            const joinData = {
                roomId: roomId,
                playerName: options.playerName || 'Player'
            };

            console.log('[SocketManager] Joining room:', roomId);

            // Use acknowledgment for reliable confirmation
            this.socket.emit('room:join', joinData, (response) => {
                if (response.error) {
                    reject(new Error(response.error));
                } else {
                    this.roomId = response.roomId; // Immediate update
                    resolve(response);
                }
            });

            // Timeout if no acknowledgment
            setTimeout(() => {
                if (!this.roomId) {
                    reject(new Error('Room join timeout'));
                }
            }, 10000);
        });
    }

    /**
     * Leave current room
     */
    leaveRoom() {
        if (this.roomId && this.connected) {
            this.socket.emit('room:leave');
            this.roomId = null;
            this.remotePlayers.clear();
            this.state = 'connected';
            this.game.uiManager?.showNetworkStatus(null);
        }
    }

    /**
     * Send player position/state update
     */
    sendPlayerUpdate(position, rotation, animation = 'idle', heldItem = '') {
        if (!this.connected || !this.roomId) return;

        const payload = {
            position: { x: position.x, y: position.y, z: position.z },
            rotation: { x: rotation.x, y: rotation.y },
            animation,
            heldItem
        };

        // Debug payload size (once per 5s)
        if (Math.random() < 0.01) {
            const str = JSON.stringify(payload);
            // console.log(`[Network] Payload size: ${str.length} bytes`);
        }

        this.socket.emit('player:update', payload);
    }

    /**
     * Send block change
     */
    sendBlockChange(x, y, z, blockType) {
        if (!this.connected || !this.roomId) return;

        this.socket.emit('block:change', {
            x: Math.floor(x),
            y: Math.floor(y),
            z: Math.floor(z),
            blockType: blockType || ''
        });
    }

    /**
     * Get shareable room link
     */
    getShareableLink() {
        if (!this.roomId) return null;

        const url = new URL(window.location.href);
        url.searchParams.set('room', this.roomId);
        return url.toString();
    }

    /**
     * Update player count in UI
     */
    _updatePlayerCount() {
        const count = this.remotePlayers.size + 1; // +1 for local player
        this.game.uiManager?.updatePlayerCount(count);
    }

    /**
     * Disconnect from server
     */
    disconnect() {
        if (this.socket) {
            console.log('[SocketManager] Disconnecting...');
            this.socket.disconnect();
            this.socket = null;
        }

        this.state = 'disconnected';
        this.roomId = null;
        this.remotePlayers.clear();
        this.game.uiManager?.showNetworkStatus(null);
    }

    /**
     * Check if in a room
     */
    isInRoom() {
        return this.state === 'in-room' && this.roomId !== null;
    }

    /**
     * Check if connected (for backward compatibility)
     */
    isConnected() {
        return this.connected;
    }
}
